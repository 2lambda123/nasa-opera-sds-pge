#!/usr/bin/env groovy

pipeline {
    agent any
    environment {
        DOCKER_IMAGE_PREFIX = 'opera_pge'
        // TODO: update as newer PGE's are added
        DOCKER_IMAGE_SUFFIXES = 'dswx_hls,cslc_s1,rtc_s1,dswx_s1,disp_s1,dswx_ni'
        DOCKER_TAG = """${sh(
                     returnStdout: true,
                     script: 'echo ${GIT_BRANCH##*/}-build-test-$$'
                     ).trim()}"""
    }
    parameters {
        string(name: 'ART_DOCKER_REGISTRY', defaultValue: 'artifactory-fn.jpl.nasa.gov:16001',
               description: 'Address of Artifactory-FN Docker registry for uploading Docker images.')
        credentials (name: 'ART_CREDENTIALS',
                     defaultValue: 'artifactory-operapgebot',
                     credentialType: 'com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl',
                     description: 'Artifactory-FN credentials for account operapgebot. Used to push/pull images from Artifactory during build.',
                     required: true)
    }
    stages {
        stage('Scan for possible secrets'){
            steps{
                sh label: "Secrets scan",
                   script: """
                   #!/bin/bash

                    if [ ! -f .secrets.baseline ] ;
                    then
                        # This generated baseline file will only be temporarily available on the GitHub side and will not appear in the user's local files.
                        # Scanning an empty folder to generate an initial .secrets.baseline without secrets in the results.
                        echo "⚠️ No existing .secrets.baseline file detected. Creating a new blank baseline file."
                        mkdir empty-dir
                        detect-secrets scan empty-dir > .secrets.baseline
                        echo "✅ Blank .secrets.baseline file created successfully."
                        rm -r empty-dir
                    else
                        echo "✅ Existing .secrets.baseline file detected. No new baseline file will be created."
                    fi
                    # scripts scan repository for new secrets
                    # backup list of known secrets
                    cp -pr .secrets.baseline .secrets.new
                    # find secrets in the repository
                    detect-secrets scan --disable-plugin AbsolutePathDetectorExperimental --all-files --baseline .secrets.new \
                        --exclude-files '\\.secrets..*' \
                        --exclude-files '\\.git.*' \
                        --exclude-files 'test_results'
                    # break build when new secrets discovered
                    # function compares baseline/new secrets w/o listing results -- success(0) when new secret found
                    """

                archiveArtifacts artifacts: ".secrets.new", allowEmptyArchive: true, fingerprint: true

                sh label: "Compare scan result to baseline",
                   script: """
                   #!/bin/bash

                    source .ci/scripts/util/compare_secrets_baselines.sh
                    # test baseline versus new secret files
                    if compare_secrets .secrets.baseline .secrets.new;
                    then
                        echo "⚠️ Attention Required! ⚠️" >&2
                        echo "New secrets have been detected in your recent commit. Due to security concerns, we cannot display detailed information here and we cannot proceed until this issue is resolved." >&2
                        echo "" >&2
                        echo "Please follow the steps below on your local machine to reveal and handle the secrets:" >&2
                        echo "" >&2
                        echo "1️⃣ Run the 'detect-secrets' tool on your local machine. This tool will identify and clean up the secrets. You can find detailed instructions at this link: https://nasa-ammos.github.io/slim/continuous-testing/starter-kits/#detect-secrets" >&2
                        echo "" >&2
                        echo "2️⃣ After cleaning up the secrets, commit your changes and re-push your update to the repository." >&2
                        echo "" >&2
                        echo "Your efforts to maintain the security of our codebase are greatly appreciated!" >&2
                        exit 1
                    else
                        echo "🟢 Secrets tests PASSED! 🟢" >&1
                        echo "No new secrets were detected in comparison to any baseline configurations."  >&1
                        exit 0
                    fi
                   """
            }
        }
        stage('Build OPERA PGE Docker image(s)') {
            steps {
                script {
                    docker.withRegistry ('https://' + params.ART_DOCKER_REGISTRY, params.ART_CREDENTIALS) {
                        echo "Building ${DOCKER_IMAGE_PREFIX} docker images with tag ${DOCKER_TAG}"
                        sh label: 'Build all OPERA Docker images',
                           script: ".ci/scripts/util/build_all_images.sh $DOCKER_TAG"
                    }
                }
            }
        }
        stage('Test OPERA PGE Docker image(s)') {
            steps {
                echo "Testing ${DOCKER_IMAGE_PREFIX} docker images with tag ${DOCKER_TAG}"
                sh label: 'Test all OPERA Docker images',
                   script: ".ci/scripts/util/test_all_images.sh $DOCKER_TAG"
                junit 'test_results/**/*.xml'
                archiveArtifacts artifacts: 'test_results/**/*.log', fingerprint: true
                script {
                    def indexFiles = []
                    def reportTitles = []

                    DOCKER_IMAGE_SUFFIXES.tokenize(',').each { DOCKER_IMAGE_SUFFIX ->
                        indexFiles << "${DOCKER_IMAGE_SUFFIX}/coverage_html/index.html"
                        reportTitles << "${DOCKER_IMAGE_SUFFIX} Code Coverage"
                    }

                    publishHTML([allowMissing: true,
                                 alwaysLinkToLastBuild: true,
                                 keepAll: true,
                                 reportDir: "test_results",
                                 reportFiles: indexFiles.join(','),
                                 reportName: "Code Coverage",
                                 reportTitles: reportTitles.join(',')])
                }
            }
        }
        stage('Scan image(s) for vulnerabilities'){
            environment{
                TMPDIR = '/data/tmp'
            }
            steps{
                echo "Scanning ${DOCKER_IMAGE_PREFIX} docker images with tag ${DOCKER_TAG} for patchable vulnerabilities"
                sh label: 'Update Grype DB',
                   script: "grype db update"
                script{
                    DOCKER_IMAGE_SUFFIXES.tokenize(',').each { DOCKER_IMAGE_SUFFIX ->
                        echo "Checking ${DOCKER_IMAGE_PREFIX}/${DOCKER_IMAGE_SUFFIX} docker image with tag ${DOCKER_TAG}"
                        sh label: "Check ${DOCKER_IMAGE_PREFIX}/${DOCKER_IMAGE_SUFFIX} OPERA Docker image",
                           script: """
                           grype ${DOCKER_IMAGE_PREFIX}/${DOCKER_IMAGE_SUFFIX}:$DOCKER_TAG --only-fixed -o template -t .ci/jenkins/grype_html.tmpl --file test_results/${DOCKER_IMAGE_SUFFIX}/grype_vulnerabilities.html
                           """
                    }

                    archiveArtifacts artifacts: 'test_results/**/grype_vulnerabilities.html', fingerprint: true
                }
            }
        }
    }
    post {
        always {
            echo "Cleaning up Docker images from local host"
            sh ".ci/scripts/util/cleanup.sh ${DOCKER_TAG}"
            deleteDir()
        }
        success {
            echo 'Succeeded!'
        }
        unstable {
            echo 'Unstable :/'
        }
        failure {
            archiveArtifacts artifacts: ".secrets.diff", allowEmptyArchive: true, fingerprint: true
            echo 'Failed :('
        }
        changed {
            echo 'Things were different before...'
        }
    }
}
